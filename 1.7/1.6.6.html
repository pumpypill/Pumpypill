<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pumpy Pill</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <img src="./assets/characters/cupsey.png" alt="Cupsey Logo" style="height:48px;width:auto;vertical-align:middle;display:inline-block;">
    </header>
    <main>
        <h1 style="text-align:center;margin-bottom:16px;">Pumpy Pill</h1>
        <div class="content-container">
            <div class="game-container">
                <div class="canvas-container">
                    <canvas id="gameCanvas" width="800" height="600"></canvas>
                </div>
                <div class="instructions">
                    <p>Time your jumps carefully to navigate the obstacles!</p>
                </div>
            </div>
            <div class="info-container">
                <h2>Game Instructions</h2>
                <p>Click or tap to make your character jump. Avoid obstacles and collect points to increase your score!</p>
                <p>Each level increases the difficulty but also gives you more rewards. Watch for special patterns that may appear!</p>
            </div>
            <div class="roadmap-container">
                <h2>Roadmap</h2>
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
            </div>
            <div class="roadmap-container">
                <h2>Our Mission</h2>
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
            </div>
            <div class="roadmap-container">
                <h2>About Us</h2>
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
            </div>
            <div class="roadmap-container">
                <h2>Contact Us</h2>
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
            </div>
            <div class="roadmap-container">
                <h2>Bug Reports and Feature Requests</h2>
                <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
            </div>            
        </div>
    </main>
    <footer>
        THIS IS JUST A BETA. NO TOKEN AT THIS TIME
    </footer>
    <script type="module">
    // Simple error tracking
    window.addEventListener('error', function(e) {
        console.error('Runtime error:', e.error.message);
    }, {passive: true});

    window.addEventListener('unhandledrejection', function(e) {
        console.error('Unhandled promise rejection:', e.reason);
    }, {passive: true});

    import { Player } from "./js/player.js";
    import { Obstacles } from "./js/obstacles.js";
    import { ChartTrail } from "./js/chart.js";
    import { Particles } from "./js/particles.js";
    import { DifficultyManager } from "./js/difficulty.js";
    import { CharacterManager } from "./js/characterManager.js";
    import { GameState } from "./js/gameState.js";
    import { InputManager } from "./js/inputManager.js";
    import { UIManager } from "./js/uiManager.js";
    import { PerformanceMonitor } from "./js/performanceMonitor.js";

    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');

    // Game constants
    var PHYSICS = {
        GRAVITY: 0.12,
        JUMP: -3.5,
        MAX_FALL: 4,
        BIRD_RADIUS: 24
    };

    var OBSTACLES = {
        WIDTH: 70,
        BASE_GAP: 180,
        BASE_SPACING: 300,
        MIN_GAP: 140
    };

    var CHART = {
        CANDLE_WIDTH: 20,
        HEIGHT: 140,
        BOTTOM_MARGIN: 25,
        MAX_CANDLES: 50 // Limit for performance
    };

    // Character definitions
    var CHARACTERS = [
        {
            id: 'Alon',
            name: 'Alon',
            image: new Image(),
            src: './assets/characters/alon.png', // Correct relative path
            width: 68,
            height: 68,
            color: '#ffd700' // Fallback color
        },
        {
            id: 'cupsey',
            name: 'Cupsey',
            image: new Image(),
            src: './assets/characters/cupsey.png', // Correct relative path
            width: 68,
            height: 68,
            color: '#4CAF50' // Fallback color
        }
    ];

    // Initialize game state management
    const gameState = new GameState();
    gameState.setLoading(); // Start in loading state

    // Add loading state
    var assetsLoaded = false;
    var loadingProgress = 0;
    var totalAssets = CHARACTERS.length;
    var loadedAssets = 0;

    // Improved character loading with preloading and loading screen
    CHARACTERS.forEach(char => {
        char.loaded = false;
        char.image.onerror = function() {
            // Add retries for failed image loads
            if (!char.retryCount || char.retryCount < 3) {
                char.retryCount = (char.retryCount || 0) + 1;
                setTimeout(() => char.image.src = char.src, 1000);
            } else {
                console.error(`Failed to load image after retries: ${char.src}`);
                char.loaded = false;
                loadedAssets++;
                loadingProgress = (loadedAssets / totalAssets) * 100;
                // Only set assetsLoaded if all images loaded successfully
                if (loadedAssets === totalAssets && CHARACTERS.every(c => c.loaded)) {
                    assetsLoaded = true;
                    gameState.setStart(); // Move to start screen when assets loaded
                }
            }
        };
        char.image.onload = function() {
            console.log(`Successfully loaded: ${char.src}`);
            char.loaded = true;
            loadedAssets++;
            loadingProgress = (loadedAssets / totalAssets) * 100;
            // Only set assetsLoaded if all images loaded successfully
            if (loadedAssets === totalAssets && CHARACTERS.every(c => c.loaded)) {
                assetsLoaded = true;
                gameState.setStart(); // Move to start screen when assets loaded
            }
        };
        char.image.src = char.src;
    });

    // Character system (modularized with gameState)
    const characterManager = new CharacterManager(CHARACTERS, canvas, gameState);

    // Player (using Player class)
    var bird = new Player(
        canvas.width * 0.25,
        canvas.height / 2,
        characterManager.getSelectedCharacter(),
        PHYSICS
    );

    // Difficulty system (modularized)
    const difficulty = new DifficultyManager(OBSTACLES);

    // Obstacles system
    var obstacles = new Obstacles(canvas.height, OBSTACLES, difficulty.pipeGap, difficulty.pipeSpacing);

    // Particles system (modularized)
    const particles = new Particles(12); // 12 = MAX_PARTICLES

    // Chart system (modularized)
    var chart = new ChartTrail(canvas, CHART);

    // Initialize input manager to handle all user interactions
    function handleJumpAction() {
        if (gameState.isStartScreen()) {
            if (assetsLoaded) {
                resetGame();
                gameState.startGame();
            }
        } else if (gameState.isGameOver()) {
            resetGame();
            gameState.startGame();
        } else if (gameState.isPlaying()) {
            // Only pump/jump during active gameplay
            try {
                bird.jump(PHYSICS.JUMP);
                // Add jump visual feedback
                for (let i = 0; i < 3; i++) {
                    particles.add(
                        bird.x - PHYSICS.BIRD_RADIUS/2 + Math.random() * PHYSICS.BIRD_RADIUS,
                        bird.y + PHYSICS.BIRD_RADIUS/2,
                        '#00d4ff'
                    );
                }
            } catch (error) {
                console.error('Jump error:', error);
            }
        }
    }

    const inputManager = new InputManager(canvas, gameState, handleJumpAction, characterManager);

    // Initialize UI Manager
    const uiManager = new UIManager(canvas, gameState, difficulty);

    // Initialize Performance Monitor
    const performanceMonitor = new PerformanceMonitor();

    // Debug toggle for performance monitoring
    const debugMode = false; // Set to false for production builds
    performanceMonitor.toggle(debugMode);

    // Preload level up sound for better performance
    const levelUpSound = new Audio();
    levelUpSound.preload = 'auto';
    levelUpSound.src = './assets/sounds/level_up.mp3';

    function update(timestamp) {
        // Update performance monitor
        performanceMonitor.update(timestamp);

        // Only update game when playing
        if (!assetsLoaded || !gameState.isPlaying()) return;

        // Physics (use Player class)
        bird.update(PHYSICS.GRAVITY, PHYSICS.MAX_FALL);

        // World progression
        gameState.updateWorldX(difficulty.speed);
        gameState.updateScroll(difficulty.speed);

        // Update pipes (obstacles)
        obstacles.updatePipes(difficulty.speed, canvas.width);

        // Boundary collision
        if (bird.y + PHYSICS.BIRD_RADIUS > canvas.height - 5 || 
            bird.y - PHYSICS.BIRD_RADIUS < 5) {
            gameState.endGame();
            particles.add(bird.x, bird.y, '#ef5350');
            return;
        }

        // Pipe collision
        try {
            if (obstacles.checkCollision(bird, PHYSICS)) {
                gameState.endGame();
                particles.add(bird.x, bird.y, '#ef5350');
                return;
            }
        } catch (error) {
            console.error('Error checking collision:', error);
            gameState.endGame();
            return;
        }

        // Scoring with safety checks
        if (obstacles.pipes && obstacles.pipes.length > 0) {
            for (var i = 0; i < obstacles.pipes.length; i++) {
                var pipe = obstacles.pipes[i];
                if (pipe && !pipe.scored && pipe.x + OBSTACLES.WIDTH / 2 < bird.x) {
                    pipe.scored = true;
                    gameState.incrementScore(1); // Ensure this is called
                    gameState.updatePortfolio(Math.floor(750 * (1 + difficulty.level * 0.08)));
                    particles.add(bird.x, bird.y, '#26a69a');
                    if (difficulty.levelUp()) {
                        // Play level up sound
                        try {
                            levelUpSound.currentTime = 0;
                            levelUpSound.play();
                        } catch (e) {
                            // Ignore play errors (e.g., user gesture not yet given)
                        }
                        gameState.updatePortfolio(difficulty.level * 1500);
                        particles.add(bird.x, bird.y, '#ffd700');
                        particles.add(bird.x, bird.y, '#00d4ff');
                        obstacles.updateDifficulty(difficulty.pipeGap, difficulty.pipeSpacing);
                    }
                }
            }
        }

        particles.update();
    }

    function draw() {
        // Clear and draw background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0d1421';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // --- Draw volume bar floor decoration ---
        drawVolumeBars(ctx, canvas, 48, 40);

        // Draw grid
        ctx.strokeStyle = '#1a1f2e';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        const gridOffset = gameState.getScroll() % 50;
        for (let x = -gridOffset; x < canvas.width + 50; x += 50) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
        }
        for (let y = 0; y < canvas.height; y += 50) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();

        // Draw chart
        try {
            chart.updateChart(gameState.getWorldX(), bird.y);
            chart.draw(ctx, gameState.getWorldX(), bird.x, bird.y);
        } catch (error) {
            console.error('Chart error:', error);
        }

        // Draw obstacles
        try {
            obstacles.draw(ctx, difficulty.level, canvas.height);
        } catch (error) {
            console.error('Obstacles draw error:', error);
        }

        // Draw player
        try {
            bird.draw(ctx, PHYSICS.BIRD_RADIUS);
        } catch (error) {
            console.error('Player draw error:', error);
        }

        // Draw particles
        particles.draw(ctx);

        // Draw UI based on game state
        if (gameState.isLoading()) {
            uiManager.drawLoadingScreen(loadingProgress);
        } else if (gameState.isStartScreen()) {
            uiManager.drawStartScreen(characterManager);
        } else if (gameState.isGameOver()) {
            uiManager.drawGameOverScreen(characterManager);
        } else {
            uiManager.drawUI();
        }

        // Always draw debug info
        if (debugMode) {
            uiManager.drawDebugInfo(
                performanceMonitor.getFPS(),
                performanceMonitor.getFrameTime().toFixed(1),
                performanceMonitor.getFrameTimeVariance().toFixed(1)
            );
        }
    }

    // --- Volume Bar Floor Decoration ---
    function drawVolumeBars(ctx, canvas, barCount = 48, barHeight = 40) {
        const barWidth = canvas.width / barCount;
        const baseY = canvas.height;
        
        // Pre-calculate bar heights and reuse
        const heights = [];
        for (let i = 0; i < barCount; i++) {
            heights[i] = Math.floor(
                (Math.sin(i * 2.1) + 1) * 0.5 * (barHeight * 0.7) +
                (Math.abs(Math.cos(i * 1.7)) * (barHeight * 0.3))
            );
        }
        
        // Batch render all red bars first, then green bars
        ctx.globalAlpha = 0.18;
        
        // Draw all red bars
        ctx.fillStyle = "#e05a5a";
        for (let i = 0; i < barCount; i += 2) {
            ctx.fillRect(i * barWidth, baseY - heights[i], barWidth - 1, heights[i]);
        }
        
        // Draw all green bars
        ctx.fillStyle = "#3fa97c";
        for (let i = 1; i < barCount; i += 2) {
            ctx.fillRect(i * barWidth, baseY - heights[i], barWidth - 1, heights[i]);
        }
        
        ctx.globalAlpha = 1.0;
    }

    function resetGame() {
        // Re-instantiate player to avoid stale references
        bird = new Player(
            canvas.width * 0.25,
            canvas.height / 2,
            characterManager.getSelectedCharacter(),
            PHYSICS
        );
        
        // Reset all systems properly using their reset methods
        difficulty.reset();
        obstacles.reset(canvas.height, difficulty.pipeGap, difficulty.pipeSpacing);
        chart.reset();
        particles.reset();
        gameState.reset();
        performanceMonitor.reset();
        
        console.log("Game reset complete, gameOver =", gameState.isGameOver());
    }

    // Optimized game loop with error handling
    function gameLoop(timestamp) {
        try {
            if (performanceMonitor.lastTime === 0) {
                performanceMonitor.start(timestamp);
            }
            update(timestamp);
            draw();
        } catch (error) {
            console.error('Game loop error:', error);
            // Don't stop the game loop, just log the error
        }
        requestAnimationFrame(gameLoop);
    }

    // Add a global reference to the current notification animation
    let currentNotificationAnimation = null;

    // After obstacles system initialization
    // Update UI Manager to be aware of obstacles pattern
    function updateUIWithPattern(pattern) {
        uiManager.currentPattern = pattern;

        // Create a pattern change notification effect
        if (gameState.isPlaying() && pattern) {
            // Cancel any existing animation
            if (currentNotificationAnimation) {
                cancelAnimationFrame(currentNotificationAnimation);
                currentNotificationAnimation = null;
            }

            // Create text notification at top of screen
            const notification = {
                text: pattern.charAt(0).toUpperCase() + pattern.slice(1) + " pattern!",
                x: canvas.width / 2,
                y: 100,
                opacity: 1.0,
                color: getPatternColor(pattern)
            };

            // Animate the notification
            let frameCount = 0;
            const animateNotification = () => {
                frameCount++;
                ctx.save();
                ctx.globalAlpha = notification.opacity;
                ctx.font = 'bold 24px "SF Pro Display", sans-serif';
                ctx.fillStyle = notification.color;
                ctx.textAlign = 'center';
                ctx.fillText(notification.text, notification.x, notification.y);
                ctx.restore();

                notification.y -= 0.5;
                notification.opacity -= 0.01;

                if (frameCount < 100 && notification.opacity > 0) {
                    currentNotificationAnimation = requestAnimationFrame(animateNotification);
                } else {
                    currentNotificationAnimation = null; // Clear the reference when animation ends
                }
            };

            currentNotificationAnimation = requestAnimationFrame(animateNotification);
        }
    }

    function getPatternColor(pattern) {
        switch(pattern) {
            case 'staircase': return '#E57373'; // Red-ish
            case 'wave': return '#64B5F6';      // Blue-ish
            case 'zigzag': return '#FFD54F';    // Yellow-ish
            case 'narrow': return '#9575CD';    // Purple-ish
            default: return '#81C784';          // Green-ish for standard
        }
    }
    
    // Modify the obstacles object to notify on pattern change
    const originalSwitchPattern = obstacles.switchPattern;
    obstacles.switchPattern = function() {
        originalSwitchPattern.apply(this, arguments);
        updateUIWithPattern(this.currentPattern);
    };
    
    // Initialize with current pattern
    updateUIWithPattern(obstacles.currentPattern);

    // Start the game
    gameLoop();
</script>
</body>
</html>