<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pumpy Pills - Enhanced Trading Experience</title>
    <style>
        body { 
            margin: 0; 
            background: #0d1421; 
            color: white; 
            font-family: "SF Pro Display", "Segoe UI", system-ui, sans-serif; 
            text-align: center; 
            overflow: hidden;
            user-select: none;
        }
        canvas { 
            display: block; 
            margin: 0 auto; 
            background: #0d1421; 
            border: 2px solid #1e2329; 
            border-radius: 8px; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5); 
            cursor: pointer;
        }
        .instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 12px;
        }
        .character-select {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        .character-option {
            width: 60px;
            height: 60px;
            border: 2px solid #1e2329;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .character-option.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
        }
        .character-pill {
            width: 20px;
            height: 40px;
            position: relative;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="instructions">Use SPACEBAR or click to jump and navigate through the trading obstacles</div>
    <script type="module">
    // Simple error tracking
    window.addEventListener('error', function(e) {
        console.error('Runtime error:', e.error.message);
    });

    window.addEventListener('unhandledrejection', function(e) {
        console.error('Unhandled promise rejection:', e.reason);
    });

    import { Player } from "./js/player.js";
    import { Obstacles } from "./js/obstacles.js";
    import { ChartTrail } from "./js/chart.js";
    import { Particles } from "./js/particles.js";
    import { DifficultyManager } from "./js/difficulty.js";
    import { CharacterManager } from "./js/characterManager.js";
    import { GameState } from "./js/gameState.js";
    import { InputManager } from "./js/inputManager.js";
    import { UIManager } from "./js/uiManager.js";
    import { PerformanceMonitor } from "./js/performanceMonitor.js";

    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');

    // Game constants
    var PHYSICS = {
        GRAVITY: 0.12,
        JUMP: -3.5,
        MAX_FALL: 4,
        BIRD_RADIUS: 24
    };

    var OBSTACLES = {
        WIDTH: 70,
        BASE_GAP: 180,
        BASE_SPACING: 300,
        MIN_GAP: 140
    };

    var CHART = {
        CANDLE_WIDTH: 20,
        HEIGHT: 140,
        BOTTOM_MARGIN: 25,
        MAX_CANDLES: 50 // Limit for performance
    };

    // Character definitions
    var CHARACTERS = [
        {
            id: 'Alon',
            name: 'Alon',
            image: new Image(),
            src: './1.7/assets/characters/alon.png', // Adjusted for GitHub Pages
            width: 68,
            height: 68,
            color: '#ffd700' // Fallback color
        },
        {
            id: 'cupsey',
            name: 'Cupsey',
            image: new Image(),
            src: './1.7/assets/characters/cupsey.png', // Adjusted for GitHub Pages
            width: 68,
            height: 68,
            color: '#4CAF50' // Fallback color
        }
    ];

    // Initialize game state management
    const gameState = new GameState();
    gameState.setLoading(); // Start in loading state

    // Add loading state
    var assetsLoaded = false;
    var loadingProgress = 0;
    var totalAssets = CHARACTERS.length;
    var loadedAssets = 0;

    // Improved character loading with preloading and loading screen
    CHARACTERS.forEach(char => {
        char.loaded = false;
        char.image.onerror = function() {
            // Add retries for failed image loads
            if (!char.retryCount || char.retryCount < 3) {
                char.retryCount = (char.retryCount || 0) + 1;
                setTimeout(() => char.image.src = char.src, 1000);
            } else {
                console.error(`Failed to load image after retries: ${char.src}`);
                char.loaded = false;
                loadedAssets++;
                loadingProgress = (loadedAssets / totalAssets) * 100;
                // Only set assetsLoaded if all images loaded successfully
                if (loadedAssets === totalAssets && CHARACTERS.every(c => c.loaded)) {
                    assetsLoaded = true;
                    gameState.setStart(); // Move to start screen when assets loaded
                }
            }
        };
        char.image.onload = function() {
            console.log(`Successfully loaded: ${char.src}`);
            char.loaded = true;
            loadedAssets++;
            loadingProgress = (loadedAssets / totalAssets) * 100;
            // Only set assetsLoaded if all images loaded successfully
            if (loadedAssets === totalAssets && CHARACTERS.every(c => c.loaded)) {
                assetsLoaded = true;
                gameState.setStart(); // Move to start screen when assets loaded
            }
        };
        char.image.src = char.src;
    });

    // Character system (modularized with gameState)
    const characterManager = new CharacterManager(CHARACTERS, canvas, gameState);

    // Player (using Player class)
    var bird = new Player(
        canvas.width * 0.25,
        canvas.height / 2,
        characterManager.getSelectedCharacter(),
        PHYSICS
    );

    // Difficulty system (modularized)
    const difficulty = new DifficultyManager(OBSTACLES);

    // Obstacles system
    var obstacles = new Obstacles(canvas.height, OBSTACLES, difficulty.pipeGap, difficulty.pipeSpacing);

    // Particles system (modularized)
    const particles = new Particles(12); // 12 = MAX_PARTICLES

    // Chart system (modularized)
    var chart = new ChartTrail(canvas, CHART);

    // Initialize input manager to handle all user interactions
    function handleJumpAction() {
        if (gameState.isStartScreen()) {
            if (assetsLoaded) {
                resetGame();
                gameState.startGame();
            }
        } else if (gameState.isGameOver()) {
            resetGame();
            gameState.startGame();
        } else if (gameState.isPlaying()) {
            // Only pump/jump during active gameplay
            try {
                bird.jump(PHYSICS.JUMP);
                // Add jump visual feedback
                for (let i = 0; i < 3; i++) {
                    particles.add(
                        bird.x - PHYSICS.BIRD_RADIUS/2 + Math.random() * PHYSICS.BIRD_RADIUS,
                        bird.y + PHYSICS.BIRD_RADIUS/2,
                        '#00d4ff'
                    );
                }
            } catch (error) {
                console.error('Jump error:', error);
            }
        }
    }

    const inputManager = new InputManager(canvas, gameState, handleJumpAction, characterManager);

    // Initialize UI Manager
    const uiManager = new UIManager(canvas, gameState, difficulty);

    // Initialize Performance Monitor
    const performanceMonitor = new PerformanceMonitor();

    // Debug toggle for performance monitoring
    const debugMode = false; // Set to false for production builds
    performanceMonitor.toggle(debugMode);

    function update(timestamp) {
        // Update performance monitor
        performanceMonitor.update(timestamp);

        // Only update game when playing
        if (!assetsLoaded || !gameState.isPlaying()) return;

        // Physics (use Player class)
        bird.update(PHYSICS.GRAVITY, PHYSICS.MAX_FALL);

        // World progression
        gameState.updateWorldX(difficulty.speed);
        gameState.updateScroll(difficulty.speed);

        // Update pipes (obstacles)
        obstacles.updatePipes(difficulty.speed, canvas.width);

        // Boundary collision
        if (bird.y + PHYSICS.BIRD_RADIUS > canvas.height - 5 || 
            bird.y - PHYSICS.BIRD_RADIUS < 5) {
            gameState.endGame();
            particles.add(bird.x, bird.y, '#ef5350');
            return;
        }

        // Pipe collision
        try {
            if (obstacles.checkCollision(bird, PHYSICS)) {
                gameState.endGame();
                particles.add(bird.x, bird.y, '#ef5350');
                return;
            }
        } catch (error) {
            console.error('Error checking collision:', error);
            gameState.endGame();
            return;
        }

        // Scoring with safety checks
        if (obstacles.pipes && obstacles.pipes.length > 0) {
            for (var i = 0; i < obstacles.pipes.length; i++) {
                var pipe = obstacles.pipes[i];
                if (pipe && !pipe.scored && pipe.x + OBSTACLES.WIDTH / 2 < bird.x) {
                    pipe.scored = true;
                    gameState.incrementScore(1); // Ensure this is called
                    gameState.updatePortfolio(Math.floor(750 * (1 + difficulty.level * 0.08)));
                    particles.add(bird.x, bird.y, '#26a69a');
                    if (difficulty.levelUp()) {
                        gameState.updatePortfolio(difficulty.level * 1500);
                        particles.add(bird.x, bird.y, '#ffd700');
                        particles.add(bird.x, bird.y, '#00d4ff');
                        obstacles.updateDifficulty(difficulty.pipeGap, difficulty.pipeSpacing);
                    }
                }
            }
        }

        particles.update();
    }

    function draw() {
        // Clear and draw background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0d1421';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw grid
        ctx.strokeStyle = '#1a1f2e';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        const gridOffset = gameState.getScroll() % 50;
        for (let x = -gridOffset; x < canvas.width + 50; x += 50) {
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
        }
        for (let y = 0; y < canvas.height; y += 50) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();

        // Draw chart
        try {
            chart.updateChart(gameState.getWorldX(), bird.y);
            chart.draw(ctx, gameState.getWorldX(), bird.x, bird.y);
        } catch (error) {
            console.error('Chart error:', error);
        }

        // Draw obstacles
        try {
            obstacles.draw(ctx, difficulty.level, canvas.height);
        } catch (error) {
            console.error('Obstacles draw error:', error);
        }

        // Draw player
        try {
            bird.draw(ctx, PHYSICS.BIRD_RADIUS);
        } catch (error) {
            console.error('Player draw error:', error);
        }

        // Draw particles
        particles.draw(ctx);

        // Draw UI based on game state
        if (gameState.isLoading()) {
            uiManager.drawLoadingScreen(loadingProgress);
        } else if (gameState.isStartScreen()) {
            uiManager.drawStartScreen(characterManager);
        } else if (gameState.isGameOver()) {
            uiManager.drawGameOverScreen(characterManager);
        } else {
            uiManager.drawUI();
        }

        // Always draw debug info
        if (debugMode) {
            uiManager.drawDebugInfo(
                performanceMonitor.getFPS(),
                performanceMonitor.getFrameTime().toFixed(1),
                performanceMonitor.getFrameTimeVariance().toFixed(1)
            );
        }
    }

    function resetGame() {
        // Re-instantiate player to avoid stale references
        bird = new Player(
            canvas.width * 0.25,
            canvas.height / 2,
            characterManager.getSelectedCharacter(),
            PHYSICS
        );
        
        // Reset all systems properly using their reset methods
        difficulty.reset();
        obstacles.reset(canvas.height, difficulty.pipeGap, difficulty.pipeSpacing);
        chart.reset();
        particles.reset();
        gameState.reset();
        performanceMonitor.reset();
        
        console.log("Game reset complete, gameOver =", gameState.isGameOver());
    }

    // Optimized game loop with error handling
    function gameLoop(timestamp) {
        try {
            if (performanceMonitor.lastTime === 0) {
                performanceMonitor.start(timestamp);
            }
            update(timestamp);
            draw();
        } catch (error) {
            console.error('Game loop error:', error);
            // Don't stop the game loop, just log the error
        }
        requestAnimationFrame(gameLoop);
    }

    // Add a global reference to the current notification animation
    let currentNotificationAnimation = null;

    // After obstacles system initialization
    // Update UI Manager to be aware of obstacles pattern
    function updateUIWithPattern(pattern) {
        uiManager.currentPattern = pattern;

        // Create a pattern change notification effect
        if (gameState.isPlaying() && pattern) {
            // Cancel any existing animation
            if (currentNotificationAnimation) {
                cancelAnimationFrame(currentNotificationAnimation);
                currentNotificationAnimation = null;
            }

            // Create text notification at top of screen
            const notification = {
                text: pattern.charAt(0).toUpperCase() + pattern.slice(1) + " pattern!",
                x: canvas.width / 2,
                y: 100,
                opacity: 1.0,
                color: getPatternColor(pattern)
            };

            // Animate the notification
            let frameCount = 0;
            const animateNotification = () => {
                frameCount++;
                ctx.save();
                ctx.globalAlpha = notification.opacity;
                ctx.font = 'bold 24px "SF Pro Display", sans-serif';
                ctx.fillStyle = notification.color;
                ctx.textAlign = 'center';
                ctx.fillText(notification.text, notification.x, notification.y);
                ctx.restore();

                notification.y -= 0.5;
                notification.opacity -= 0.01;

                if (frameCount < 100 && notification.opacity > 0) {
                    currentNotificationAnimation = requestAnimationFrame(animateNotification);
                } else {
                    currentNotificationAnimation = null; // Clear the reference when animation ends
                }
            };

            currentNotificationAnimation = requestAnimationFrame(animateNotification);
        }
    }

    function getPatternColor(pattern) {
        switch(pattern) {
            case 'staircase': return '#E57373'; // Red-ish
            case 'wave': return '#64B5F6';      // Blue-ish
            case 'zigzag': return '#FFD54F';    // Yellow-ish
            case 'narrow': return '#9575CD';    // Purple-ish
            default: return '#81C784';          // Green-ish for standard
        }
    }
    
    // Modify the obstacles object to notify on pattern change
    const originalSwitchPattern = obstacles.switchPattern;
    obstacles.switchPattern = function() {
        originalSwitchPattern.apply(this, arguments);
        updateUIWithPattern(this.currentPattern);
    };
    
    // Initialize with current pattern
    updateUIWithPattern(obstacles.currentPattern);

    // Start the game
    gameLoop();
</script>
</body>
</html>